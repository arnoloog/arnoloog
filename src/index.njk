---
layout: layouts/base.njk
title: ARNOLOOG
---

<section class="home">
  <div class="home-grid">
    {% for roll in photos.rolls %}
      <div class="roll-block" data-roll="{{ roll.name }}" style="display: contents;">
        {% for item in roll.grid | reverse %}
          {% if item.isTrigger %}
            <a href="/rolls/{{ roll.name }}/" class="grid-item grid-item--trigger">
              <img src="{{ item.src }}" loading="lazy" alt="">
            </a>
          {% else %}
            <div class="grid-item">
              <img src="{{ item.src }}" loading="lazy" alt="">
            </div>
          {% endif %}
        {% endfor %}
      </div>
    {% endfor %}
  </div>

  <div class="fast-scroll-thumb" aria-label="fast scroll"></div>
</section>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const grid = document.querySelector(".home-grid");
  if (!grid) return;

  if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

  const COLS = 3;
  const easing = "cubic-bezier(.2, 1, .3, 1)";
  const wait = (ms) => new Promise(r => setTimeout(r, ms));
  let firstPuzzle = true;

  const neighbors = (i) => {
    const r = Math.floor(i / COLS);
    const c = i % COLS;
    return [
      c > 0 && i - 1,
      c < COLS - 1 && i + 1,
      r > 0 && i - COLS,
      r < COLS - 1 && i + COLS
    ].filter(n => n !== false);
  };

  const getImg = el => el?.querySelector?.("img");

  const gridNumber = src => {
    const m = String(src || "").match(/-grid-(\d+)\./i);
    return m ? +m[1] : null;
  };

  async function animateMove(fromEl, toEl, duration) {
    const img = getImg(fromEl);
    if (!img) return;

    const a = fromEl.getBoundingClientRect();
    const b = toEl.getBoundingClientRect();

    let dx = b.left - a.left;
    let dy = b.top - a.top;

    if (Math.abs(dx) > Math.abs(dy)) dy = 0;
    else dx = 0;

    fromEl.style.zIndex = "10";
    img.style.transition = `transform ${duration}ms ${easing}`;
    img.style.transform = `translate(${dx}px, ${dy}px)`;

    await wait(duration);

    img.style.transition = "none";
    img.style.transform = "translate(0,0)";
    fromEl.style.zIndex = "";

    requestAnimationFrame(() => img.style.transition = "");
  }

  const io = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (!entry.isIntersecting) return;

      const trigger = entry.target;
      const block = trigger.closest(".roll-block");
      if (block?.dataset.done) return;

      const tiles = Array.from(block.querySelectorAll(".grid-item"));
      const triggerEl = block.querySelector(".grid-item--trigger");
      if (!triggerEl) return;

      const gridTiles = tiles
        .map(el => ({ el, n: gridNumber(getImg(el)?.src) }))
        .filter(x => Number.isFinite(x.n))
        .sort((a,b) => a.n - b.n)
        .slice(-8)
        .map(x => x.el);

      if (gridTiles.length < 8) return;

      const cells = [...gridTiles, triggerEl];
      cells.forEach(el => el.classList.add("puzzle-tile"));
      grid.classList.add("puzzle-active");

      triggerEl.classList.add("puzzle-blank");

      let blank = 8;
      let prev = -1;

      (async () => {
        for (let i = 0; i < 14; i++) {
          const ns = neighbors(blank).filter(n => n !== prev);
          const pick = ns[Math.floor(Math.random() * ns.length)];

          await animateMove(cells[pick], cells[blank], 90);

          [cells[pick], cells[blank]] = [cells[blank], cells[pick]];
          prev = blank;
          blank = pick;
        }

        triggerEl.classList.remove("puzzle-blank");
        triggerEl.classList.add("trigger-reveal");
        block.dataset.done = "1";
        grid.classList.remove("puzzle-active");
      })();
    });
  }, { threshold: 0.4 });

  document.querySelectorAll(".grid-item--trigger").forEach(t => io.observe(t));
});
</script>
