---
layout: layouts/base.njk
title: ARNOLOOG
---

<section class="home">
  <div class="home-grid">
    {% for roll in photos.rolls %}
      <div class="roll-block" data-roll="{{ roll.name }}" style="display: contents;">
        {% for item in roll.grid | reverse %}
          {% if item.isTrigger %}
            <a href="/rolls/{{ roll.name }}/" class="grid-item grid-item--trigger">
              <img src="{{ item.src }}" loading="lazy" alt="">
            </a>
          {% else %}
            <div class="grid-item">
              <img src="{{ item.src }}" loading="lazy" alt="">
            </div>
          {% endif %}
        {% endfor %}
      </div>
    {% endfor %}
  </div>

  <div class="fast-scroll-thumb" aria-label="fast scroll"></div>
</section>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const grid = document.querySelector(".home-grid");
  if (!grid) return;

  if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

  const COLS = 3;
  const easing = "cubic-bezier(.2, 1, .3, 1)";
  const wait = (ms) => new Promise(r => setTimeout(r, ms));

  // enkel de allereerste puzzel op de pagina krijgt de “cinematic” timings
  let firstPuzzle = true;

  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const lerp = (a, b, t) => a + (b - a) * t;

  // smoothstep: zacht starten + zacht eindigen (geen eindsprint)
  const smoothstep = (t) => {
    t = clamp01(t);
    return t * t * (3 - 2 * t);
  };

  // timing curve (eerste clamp harder, daarna milder)
  const curve = (t) => {
    const tc = firstPuzzle ? Math.min(t, 0.93) : Math.min(t, 0.97);
    return smoothstep(tc);
  };

  const neighbors = (i) => {
    const res = [];
    const r = Math.floor(i / COLS);
    const c = i % COLS;
    if (c > 0) res.push(i - 1);
    if (c < COLS - 1) res.push(i + 1);
    if (r > 0) res.push(i - COLS);
    if (r < COLS - 1) res.push(i + COLS);
    return res;
  };

  const getImg = (el) => el && el.querySelector ? el.querySelector("img") : null;

  const gridNumber = (src) => {
    const m = String(src || "").match(/-grid-(\d+)\./i);
    return m ? parseInt(m[1], 10) : null;
  };

  function sortCellsByVisualPosition(cells) {
    const rects = cells.map(el => ({ el, r: el.getBoundingClientRect() }));
    const allTops = rects.map(x => x.r.top).sort((a,b) => a-b);
    const rowTol = Math.max(6, Math.round((rects[0]?.r.height || 100) * 0.25));

    const rowAnchors = [];
    for (const top of allTops) {
      if (!rowAnchors.length) rowAnchors.push(top);
      else if (Math.abs(top - rowAnchors[rowAnchors.length - 1]) > rowTol) rowAnchors.push(top);
      if (rowAnchors.length >= 3) break;
    }

    const rowIndexOf = (top) => {
      let best = 0, bestD = Infinity;
      for (let i = 0; i < rowAnchors.length; i++) {
        const d = Math.abs(top - rowAnchors[i]);
        if (d < bestD) { bestD = d; best = i; }
      }
      return best;
    };

    rects.sort((a, b) => {
      const ra = rowIndexOf(a.r.top);
      const rb = rowIndexOf(b.r.top);
      if (ra !== rb) return ra - rb;
      return a.r.left - b.r.left;
    });

    return rects.map(x => x.el);
  }

  function resetBlock(block) {
    const st = block && block._puzzle;
    if (!st) return;

    st.aborted = true;

    // restore originele 3x3 instantly
    for (let i = 0; i < st.cells.length; i++) {
      const img = getImg(st.cells[i]);
      if (!img) continue;
      img.style.opacity = "";
      img.style.transition = "none";
      img.style.transform = "translate(0,0)";
      img.src = st.original[i] || img.src;
    }

    // blank kan op eender welke cel zitten -> verwijder overal
    st.cells.forEach(el => el.classList.remove("puzzle-blank", "puzzle-tile"));
    st.triggerEl.classList.remove("trigger-reveal", "is-breathe");

    grid.classList.remove("puzzle-active");

    delete block._puzzle;

    if (block.dataset.puzzleDone !== "1") block.dataset.puzzleState = "idle";
  }

  async function runPuzzleForBlock(block) {
    if (!block) return;

    if (block.dataset.puzzleDone === "1") return;
    if (block.dataset.puzzleState === "running") return;

    resetBlock(block);

    const tiles = Array.from(block.querySelectorAll(".grid-item, .grid-item--trigger"));
    const triggerEl = tiles.find(el => el.classList.contains("grid-item--trigger"));
    if (!triggerEl) return;

    const gridTiles = tiles
      .filter(el => !el.classList.contains("grid-item--trigger"))
      .map(el => ({ el, n: gridNumber(getImg(el)?.src) }))
      .filter(x => Number.isFinite(x.n));

    if (gridTiles.length < 11) return;

    gridTiles.sort((a, b) => a.n - b.n);

    const withoutLast3 = gridTiles.slice(0, -3);
    if (withoutLast3.length < 8) return;

    const eight = withoutLast3.slice(-8).map(x => x.el);

    let cells = [...eight, triggerEl];
    cells = sortCellsByVisualPosition(cells);

    const original = cells.map(el => getImg(el)?.src || "");

    let blankIndex = cells.indexOf(triggerEl);
    if (blankIndex < 0) return;

    block.dataset.puzzleState = "running";

    block._puzzle = {
      aborted: false,
      cells,
      original,
      triggerEl,
      blankIndex
    };

    // state is 9, met null op blankIndex
    const state = original.slice();
    state[blankIndex] = null;

    grid.classList.add("puzzle-active");
    cells.forEach(el => el.classList.add("puzzle-tile"));

    triggerEl.classList.remove("is-breathe", "trigger-reveal");

    // blank moet MEEschuiven
    const setBlank = (newBlank) => {
      const st = block._puzzle;
      if (!st || st.aborted) return;
      st.cells.forEach(el => el.classList.remove("puzzle-blank"));
      st.cells[newBlank].classList.add("puzzle-blank");
      st.blankIndex = newBlank;
    };

    const applyCell = (idx) => {
      const img = getImg(cells[idx]);
      if (!img) return;
      const v = state[idx];
      if (v === null) {
        img.style.opacity = "0";
      } else {
        if (img.src !== v) img.src = v;
        img.style.opacity = "1";
      }
    };

    // init blank correct zetten
    setBlank(blankIndex);

    // shuffle hoeveelheid
    const shuffleMoves = firstPuzzle ? 18 : 10;

    // timings (eerste cinematic, daarna sneller maar niet “super super rap”)
    const durAt = (t) => {
      const u = curve(t);
      return firstPuzzle
        ? Math.round(lerp(160, 50, u))   // cinematic
        : Math.round(lerp(105, 55, u));  // scroll: snappy maar leesbaar
    };

    const gapAt = (t) => {
      const u = curve(t);
      return firstPuzzle
        ? Math.round(lerp(95, 20, u))    // cinematic
        : Math.round(lerp(40, 16, u));   // scroll: geen machinegun
    };

    // SHUFFLE random-walk
    const moves = [];
    let prev = -1;

    for (let k = 0; k < shuffleMoves; k++) {
      const st = block._puzzle;
      if (!st || st.aborted) return resetBlock(block);

      const ns = neighbors(blankIndex).filter(n => n !== prev);
      const pick = ns[Math.floor(Math.random() * ns.length)];
      moves.push(pick);
      prev = blankIndex;

      [state[blankIndex], state[pick]] = [state[pick], state[blankIndex]];
      blankIndex = pick;
    }

    // blank naar juiste plek na shuffle
    setBlank(blankIndex);

    for (let i = 0; i < 9; i++) applyCell(i);

    async function animateMove(fromIdx, toIdx, duration) {
      const st = block._puzzle;
      if (!st || st.aborted) return false;

      const fromEl = cells[fromIdx];
      const toEl = cells[toIdx];
      if (!fromEl || !toEl) return true;

      const a = fromEl.getBoundingClientRect();
      const b = toEl.getBoundingClientRect();
      let dx = b.left - a.left;
      let dy = b.top - a.top;

      if (Math.abs(dx) > Math.abs(dy)) dy = 0;
      else dx = 0;

      const prevZ = fromEl.style.zIndex;
      const prevOv = fromEl.style.overflow;

      fromEl.style.zIndex = "50";
      fromEl.style.overflow = "visible";

      fromEl.style.transition = `transform ${duration}ms ${easing}`;
      fromEl.style.transform = `translate(${dx}px, ${dy}px)`;

      await wait(duration);

      const st2 = block._puzzle;
      if (!st2 || st2.aborted) return false;

      fromEl.style.transition = "none";
      fromEl.style.transform = "translate(0,0)";
      fromEl.style.zIndex = prevZ || "";
      fromEl.style.overflow = prevOv || "";

      requestAnimationFrame(() => { fromEl.style.transition = ""; });

      return true;
    }

    // SOLVE reverse
    for (let step = moves.length - 1; step >= 0; step--) {
      const st = block._puzzle;
      if (!st || st.aborted) return resetBlock(block);

      const t = 1 - (step / Math.max(1, moves.length - 1));
      const duration = durAt(t);
      const gap = gapAt(t);

      const from = moves[step];
      const to = blankIndex;

      const ok = await animateMove(from, to, duration);
      if (!ok) return resetBlock(block);

      [state[to], state[from]] = [state[from], state[to]];
      blankIndex = from;

      // blank meeschuiven naar nieuwe plek (vanwaar de tile kwam)
      setBlank(blankIndex);

      applyCell(to);
      applyCell(from);

      await wait(gap);
    }

    const st = block._puzzle;
    if (!st || st.aborted) return resetBlock(block);

    // restore exact originelen (puzzel klaar)
    for (let i = 0; i < 9; i++) {
      const img = getImg(cells[i]);
      if (!img) continue;
      img.style.opacity = "";
      img.style.transition = "";
      img.style.transform = "";
      img.src = original[i];
    }

    // blank weg, trigger reveal
    cells.forEach(el => el.classList.remove("puzzle-blank"));
    triggerEl.classList.add("trigger-reveal");

    window.setTimeout(() => {
      const st3 = block._puzzle;
      if (!st3 || st3.aborted) return;
      triggerEl.classList.add("is-breathe");
      triggerEl.classList.remove("trigger-reveal");
    }, firstPuzzle ? 900 : 550);

    grid.classList.remove("puzzle-active");

    block.dataset.puzzleDone = "1";
    block.dataset.puzzleState = "done";
    delete block._puzzle;

    if (firstPuzzle) firstPuzzle = false;
  }

  const io = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      const trigger = entry.target;
      const block = trigger.closest(".roll-block");
      if (!block) return;

      if (entry.isIntersecting) {
        runPuzzleForBlock(block);
      } else {
        if (block.dataset.puzzleDone !== "1" && block.dataset.puzzleState === "running") {
          resetBlock(block);
        }
      }
    });
  }, { threshold: 0.35 });

  const blocks = Array.from(grid.querySelectorAll(".roll-block"));
  blocks.forEach(block => {
    block.dataset.puzzleState = "idle";
    const trigger = block.querySelector(".grid-item--trigger");
    if (trigger) io.observe(trigger);
  });

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      blocks.forEach(b => {
        if (b.dataset.puzzleDone !== "1" && b.dataset.puzzleState === "running") resetBlock(b);
      });
    }
  });
});
</script>
