---
layout: layouts/base.njk
title: ARNOLOOG
---

<section class="home">
  <div class="home-grid">
    {% for roll in photos.rolls %}
      {# wrapper per roll zodat we per album kunnen triggeren #}
      <div class="roll-block" data-roll="{{ roll.name }}" style="display: contents;">
        {# binnen elke roll: omkeren zodat 01 onderaan zit #}
        {% for item in roll.grid | reverse %}
          {% if item.isTrigger %}
            <a href="/rolls/{{ roll.name }}/" class="grid-item grid-item--trigger">
              <img src="{{ item.src }}" loading="lazy" alt="">
            </a>
          {% else %}
            <div class="grid-item">
              <img src="{{ item.src }}" loading="lazy" alt="">
            </div>
          {% endif %}
        {% endfor %}
      </div>
    {% endfor %}
  </div>

  <div class="fast-scroll-thumb" aria-label="fast scroll"></div>
</section>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const grid = document.querySelector(".home-grid");
  if (!grid) return;

  if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

  const COLS = 3;
  const easing = "cubic-bezier(.2, 1, .3, 1)";
  const wait = (ms) => new Promise(r => setTimeout(r, ms));

  // global: eerste puzzel trager/mooier, daarna veel sneller
  let firstPuzzle = true;

  const neighbors = (i) => {
    const res = [];
    const r = Math.floor(i / COLS);
    const c = i % COLS;
    if (c > 0) res.push(i - 1);
    if (c < COLS - 1) res.push(i + 1);
    if (r > 0) res.push(i - COLS);
    if (r < COLS - 1) res.push(i + COLS);
    return res;
  };

  const getImg = (el) => el && el.querySelector ? el.querySelector("img") : null;

  // parse "...-grid-60.webp" -> 60
  const gridNumber = (src) => {
    const m = String(src || "").match(/-grid-(\d+)\./i);
    return m ? parseInt(m[1], 10) : null;
  };

  function resetBlock(block) {
    const st = block && block._puzzle;
    if (!st) return;

    st.aborted = true;

    // restore original 3x3 instantly
    for (let i = 0; i < st.cells.length; i++) {
      const img = getImg(st.cells[i]);
      if (!img) continue;
      img.style.opacity = "";
      img.style.transition = "none";
      img.style.transform = "translate(0,0)";
      img.src = st.original[i] || img.src;
    }

    st.triggerEl.classList.remove("puzzle-blank", "trigger-reveal", "is-breathe");
    st.cells.forEach(el => el.classList.remove("puzzle-tile"));
    grid.classList.remove("puzzle-active");

    delete block._puzzle;

    // als hij nog niet "done" was: terug idle zodat hij later opnieuw kan starten
    if (block.dataset.puzzleDone !== "1") block.dataset.puzzleState = "idle";
  }

  // Sorteer de 9 DOM-elements naar echte 3x3 posities (row-major)
  function sortCellsByVisualPosition(cells) {
    const rects = cells.map(el => ({ el, r: el.getBoundingClientRect() }));

    // Groepeer rijen met toleranties (want subpixel / responsive)
    const allTops = rects.map(x => x.r.top).sort((a,b) => a-b);
    const rowTol = Math.max(6, Math.round((rects[0]?.r.height || 100) * 0.25));

    // bepaal 3 row-anchors
    const rowAnchors = [];
    for (const top of allTops) {
      if (!rowAnchors.length) rowAnchors.push(top);
      else if (Math.abs(top - rowAnchors[rowAnchors.length - 1]) > rowTol) rowAnchors.push(top);
      if (rowAnchors.length >= 3) break;
    }

    const rowIndexOf = (top) => {
      let best = 0;
      let bestD = Infinity;
      for (let i = 0; i < rowAnchors.length; i++) {
        const d = Math.abs(top - rowAnchors[i]);
        if (d < bestD) { bestD = d; best = i; }
      }
      return best;
    };

    rects.sort((a, b) => {
      const ra = rowIndexOf(a.r.top);
      const rb = rowIndexOf(b.r.top);
      if (ra !== rb) return ra - rb;
      return a.r.left - b.r.left;
    });

    return rects.map(x => x.el);
  }

  async function runPuzzleForBlock(block) {
    if (!block) return;

    // al klaar? nooit meer
    if (block.dataset.puzzleDone === "1") return;

    // al bezig? doe niks
    if (block.dataset.puzzleState === "running") return;

    // cleanup van eventuele rommel
    resetBlock(block);

    const tiles = Array.from(block.querySelectorAll(".grid-item, .grid-item--trigger"));
    const triggerEl = tiles.find(el => el.classList.contains("grid-item--trigger"));
    if (!triggerEl) return;

    const gridTiles = tiles
      .filter(el => !el.classList.contains("grid-item--trigger"))
      .map(el => ({ el, n: gridNumber(getImg(el)?.src) }))
      .filter(x => Number.isFinite(x.n));

    // min: 3 zwarte (laatste) + 8 puzzel = 11 grid tiles
    if (gridTiles.length < 11) return;

    // sorteert op filename-nummer
    gridTiles.sort((a, b) => a.n - b.n);

    // laatste 3 grid = zwart -> skip
    const withoutLast3 = gridTiles.slice(0, -3);
    if (withoutLast3.length < 8) return;

    // pak de 8 net vóór die zwarte (oranje)
    const eight = withoutLast3.slice(-8).map(x => x.el);

    // 3x3 = 8 grid + trigger (blank)
    // BELANGRIJK: sorteer deze 9 elementen op echte visuele positie
    let cells = [...eight, triggerEl];
    cells = sortCellsByVisualPosition(cells);

    // originele srcs bewaren (in correcte 3x3 volgorde!)
    const original = cells.map(el => getImg(el)?.src || "");

    // blank is de trigger positie (kan midden zijn!)
    let blankIndex = cells.indexOf(triggerEl);
    if (blankIndex < 0) return;

    // lock meteen (zodat snelle scroll nooit 2x tegelijk kan starten)
    block.dataset.puzzleState = "running";

    // puzzle state op block (voor abort/reset)
    block._puzzle = {
      aborted: false,
      cells,
      original,
      triggerEl
    };

    // state = 8 images + null blank (in dezelfde volgorde als cells)
    const state = original.slice();
    state[blankIndex] = null;

    // UI flags
    grid.classList.add("puzzle-active");
    cells.forEach(el => el.classList.add("puzzle-tile"));

    // trigger is blank tijdens puzzel + breathing uit
    triggerEl.classList.add("puzzle-blank");
    triggerEl.classList.remove("is-breathe", "trigger-reveal");

    const applyCell = (idx) => {
      const img = getImg(cells[idx]);
      if (!img) return;
      const v = state[idx];
      if (v === null) {
        img.style.opacity = "0";
      } else {
        if (img.src !== v) img.src = v;
        img.style.opacity = "1";
      }
    };

    // --- SPEED PROFILE ---
    const accelPow = firstPuzzle ? 2.2 : 2.8;   // iets meer acceleratie
    const shuffleMoves = firstPuzzle ? 18 : 10; // klein beetje sneller

    const durAt = (t) => {
      const u = Math.pow(t, accelPow);
      return firstPuzzle
        ? Math.round(160 - 110 * u)  // first: ~160 -> ~50
        : Math.round(85 - 55 * u);   // others: ~85 -> ~30
    };

    const gapAt = (t) => {
      const u = Math.pow(t, accelPow);
      return firstPuzzle
        ? Math.round(95 - 75 * u)    // first: ~95 -> ~20
        : Math.round(45 - 35 * u);   // others: ~45 -> ~10
    };

    // --- SHUFFLE via random-walk (legit schuifpuzzel) ---
    const moves = [];
    let prev = -1;

    for (let k = 0; k < shuffleMoves; k++) {
      const st = block._puzzle;
      if (!st || st.aborted) return resetBlock(block);

      const ns = neighbors(blankIndex).filter(n => n !== prev);
      const pick = ns[Math.floor(Math.random() * ns.length)];
      moves.push(pick);
      prev = blankIndex;

      [state[blankIndex], state[pick]] = [state[pick], state[blankIndex]];
      blankIndex = pick;
    }

    // zet shuffled state
    for (let i = 0; i < 9; i++) applyCell(i);

    // animate 1 move: schuif tile over blank (container animatie, geen img)
    async function animateMove(fromIdx, toIdx, duration) {
      const st = block._puzzle;
      if (!st || st.aborted) return false;

      const fromEl = cells[fromIdx];
      const toEl = cells[toIdx];
      if (!fromEl || !toEl) return true;

      const a = fromEl.getBoundingClientRect();
      const b = toEl.getBoundingClientRect();
      let dx = b.left - a.left;
      let dy = b.top - a.top;

      // nooit diagonaal (moet altijd 1 stap zijn in 3x3)
      if (Math.abs(dx) > Math.abs(dy)) dy = 0;
      else dx = 0;

      const prevZ = fromEl.style.zIndex;
      const prevOv = fromEl.style.overflow;

      fromEl.style.zIndex = "50";
      fromEl.style.overflow = "visible";

      fromEl.style.transition = `transform ${duration}ms ${easing}`;
      fromEl.style.transform = `translate(${dx}px, ${dy}px)`;

      await wait(duration);

      const st2 = block._puzzle;
      if (!st2 || st2.aborted) return false;

      fromEl.style.transition = "none";
      fromEl.style.transform = "translate(0,0)";
      fromEl.style.zIndex = prevZ || "";
      fromEl.style.overflow = prevOv || "";

      requestAnimationFrame(() => { fromEl.style.transition = ""; });

      return true;
    }

    // --- SOLVE (reverse moves) ---
    for (let step = moves.length - 1; step >= 0; step--) {
      const st = block._puzzle;
      if (!st || st.aborted) return resetBlock(block);

      const t = 1 - (step / Math.max(1, moves.length - 1));
      const duration = durAt(t);
      const gap = gapAt(t);

      const from = moves[step];
      const to = blankIndex;

      const ok = await animateMove(from, to, duration);
      if (!ok) return resetBlock(block);

      [state[to], state[from]] = [state[from], state[to]];
      blankIndex = from;

      applyCell(to);
      applyCell(from);

      await wait(gap);
    }

    // Eind: exact originele layout terug + trigger reveal
    const st = block._puzzle;
    if (!st || st.aborted) return resetBlock(block);

    for (let i = 0; i < 9; i++) {
      const img = getImg(cells[i]);
      if (!img) continue;
      img.style.opacity = "";
      img.style.transition = "";
      img.style.transform = "";
      img.src = original[i];
    }

    // trigger zichtbaar + pop/fade
    triggerEl.classList.remove("puzzle-blank");
    triggerEl.classList.add("trigger-reveal");

    // breathing pas later starten
    window.setTimeout(() => {
      const st3 = block._puzzle;
      if (!st3 || st3.aborted) return;
      triggerEl.classList.add("is-breathe");
      triggerEl.classList.remove("trigger-reveal");
    }, firstPuzzle ? 900 : 550);

    grid.classList.remove("puzzle-active");

    // mark done (blijft staan)
    block.dataset.puzzleDone = "1";
    block.dataset.puzzleState = "done";
    delete block._puzzle;

    if (firstPuzzle) firstPuzzle = false;
  }

  // Start puzzel per roll bij trigger in beeld (1x)
  // + als je er te snel voorbij scrolt terwijl hij bezig is: force reset
  const io = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      const trigger = entry.target;
      const block = trigger.closest(".roll-block");
      if (!block) return;

      if (entry.isIntersecting) {
        runPuzzleForBlock(block);
      } else {
        if (block.dataset.puzzleDone !== "1" && block.dataset.puzzleState === "running") {
          resetBlock(block);
        }
      }
    });
  }, { threshold: 0.35 });

  const blocks = Array.from(grid.querySelectorAll(".roll-block"));
  blocks.forEach(block => {
    block.dataset.puzzleState = "idle";
    const trigger = block.querySelector(".grid-item--trigger");
    if (trigger) io.observe(trigger);
  });

  // extra safety: tab hidden => reset alles dat nog loopt
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      blocks.forEach(b => {
        if (b.dataset.puzzleDone !== "1" && b.dataset.puzzleState === "running") resetBlock(b);
      });
    }
  });
});
</script>
